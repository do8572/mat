if (log(runif(1)) < logr) p0 <- p
curr.time <- Sys.time()
self$samples[i,] <- c(curr.time - start.time, p0)
}
return(self$samples)
},
sample = function(){
if (self$burnin){
for (i in 1:self$nburn){
S_b <- self$sample_loop()
self$sigma <- cov(unique(S_b[,2:ncol(S_b)]), use="complete.obs")
if (all(self$sigma < 1)){
if (all(self$sigma < 1) == 1) self$sigma <- diag(self$dim)
self$sigma <- self$sigma / max(abs(self$sigma))
}
}
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)  # clear burn-in samples
}
return(self$sample_loop())
}
))
library(mvtnorm)
MHS <- R6Class("MHS",
public = list(
samples = NULL, niter = 1000, nburn = 3, burnin = FALSE, dim = NULL,
sigma = NULL, x0 = NULL, name="MHS",
target.prob = NULL, target.prob.log = NULL,
initialize = function(f, f.log, f.log.grad, dim, niter, burnin=TRUE, x0, sigma, const, epsilon, nleaps) {
if (missing(f)) stop("Target undefined")
self$target.prob <- f
if (missing(f.log)) stop("Target log undefined")
self$target.prob.log <- f.log
if (missing(dim)) stop("Dimensions undefined")
self$dim <- dim
if (missing(sigma)){
self$sigma <- diag(dim)
# A <- matrix(runif(dim^2)*10-5, ncol=dim)
# self$sigma <- t(A) %*% A
}else self$sigma <- sigma
if (missing(sigma)) self$x0 <- rnorm(dim, sd = 5)
else self$x0 <- x0
if (!missing(niter)) self$niter <- niter
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)
self$burnin <- burnin
},
proposal = function(x){
return(rmvnorm(1, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim))
},
proposal.prob = function(x){
return(dmvnorm(x=x, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim))
},
proposal.prob.log = function(x){
return(log(dmvnorm(x=x, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim)))
},
sample_loop = function(){
p0 <- self$x0
p <- p0
start.time <- Sys.time()
for (i in 1:self$niter){
p <- self$proposal(p)
p_prob.log <- self$proposal.prob.log(p)
t_prob.log <- self$target.prob.log(p)
p0_prob.log <- self$proposal.prob.log(p0)
t0_prob.log <- self$target.prob.log(p0)
logr <- (t_prob.log - p_prob.log) - (t0_prob.log - p0_prob.log)
if (is.nan(logr)) next
if (log(runif(1)) < logr) p0 <- p
curr.time <- Sys.time()
self$samples[i,] <- c(curr.time - start.time, p0)
}
return(self$samples)
},
sample = function(){
if (self$burnin){
for (i in 1:self$nburn){
S_b <- self$sample_loop()
self$sigma <- cov(unique(S_b[,2:ncol(S_b)]), use="complete.obs")
if (all(self$sigma < 1)){
if (all(self$sigma < 1) == 1) self$sigma <- diag(self$dim)
self$sigma <- self$sigma / max(abs(self$sigma))
}
}
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)  # clear burn-in samples
}
return(self$sample_loop())
}
))
```{r}
library(MASS)
library(mvtnorm)
library(ggplot2)
library(codetools)
library(R6)
library(tidyr)
library(dplyr)
library(mcmcse)
library(plotly)
library(scatterplot3d)
MHS <- R6Class("MHS",
public = list(
samples = NULL, niter = 1000, nburn = 3, burnin = FALSE, dim = NULL,
sigma = NULL, x0 = NULL, name="MHS",
target.prob = NULL, target.prob.log = NULL,
initialize = function(f, f.log, f.log.grad, dim, niter, burnin=TRUE, x0, sigma, const, epsilon, nleaps) {
if (missing(f)) stop("Target undefined")
self$target.prob <- f
if (missing(f.log)) stop("Target log undefined")
self$target.prob.log <- f.log
if (missing(dim)) stop("Dimensions undefined")
self$dim <- dim
if (missing(sigma)){
self$sigma <- diag(dim)
# A <- matrix(runif(dim^2)*10-5, ncol=dim)
# self$sigma <- t(A) %*% A
}else self$sigma <- sigma
if (missing(sigma)) self$x0 <- rnorm(dim, sd = 5)
else self$x0 <- x0
if (!missing(niter)) self$niter <- niter
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)
self$burnin <- burnin
},
proposal = function(x){
return(rmvnorm(1, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim))
},
proposal.prob = function(x){
return(dmvnorm(x=x, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim))
},
proposal.prob.log = function(x){
return(log(dmvnorm(x=x, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim)))
},
sample_loop = function(){
p0 <- self$x0
p <- p0
start.time <- Sys.time()
for (i in 1:self$niter){
p <- self$proposal(p)
p_prob.log <- self$proposal.prob.log(p)
t_prob.log <- self$target.prob.log(p)
p0_prob.log <- self$proposal.prob.log(p0)
t0_prob.log <- self$target.prob.log(p0)
logr <- (t_prob.log - p_prob.log) - (t0_prob.log - p0_prob.log)
if (is.nan(logr)) next
if (log(runif(1)) < logr) p0 <- p
curr.time <- Sys.time()
self$samples[i,] <- c(curr.time - start.time, p0)
}
return(self$samples)
},
sample = function(){
if (self$burnin){
for (i in 1:self$nburn){
S_b <- self$sample_loop()
self$sigma <- cov(unique(S_b[,2:ncol(S_b)]), use="complete.obs")
if (all(self$sigma < 1)){
if (all(self$sigma < 1) == 1) self$sigma <- diag(self$dim)
self$sigma <- self$sigma / max(abs(self$sigma))
}
}
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)  # clear burn-in samples
}
return(self$sample_loop())
}
))
first_nan <- NULL
h0 <- NULL
h1 <- NULL
plog_tmp <- NULL
p_tmp <- NULL
plog <- NULL
prop <- NULL
x_tmp <- NULL
hpx <- NULL
HMC <- R6Class("HMC",
public = list(
samples = NULL, niter = 1000, nburn = 1, burnin = FALSE, dim = NULL,
sigma = NULL, x0 = NULL, name="HMC",
target.prob = NULL, target.prob.log = NULL, target.prob.log.grad = NULL,
nleaps = 10, momentum = NULL, m0 = NULL, mL = NULL, eps = 1,
initialize = function(f, f.log, f.log.grad, dim, niter, burnin=TRUE, x0, sigma, const, epsilon, nleaps) {
if (missing(f)) stop("Target undefined")
self$target.prob <- function(x) return(-f(x))
if (missing(f.log)) stop("Target log undefined")
self$target.prob.log <- function(x) return(-f.log(x))
if (missing(f.log.grad)) stop("Target gradient undefined")
self$target.prob.log.grad <- function(x) return(-f.log.grad(x))
if (missing(dim)) stop("Dimensions undefined")
self$dim <- dim
if (missing(sigma)){
self$sigma <- diag(dim)
# A <- matrix(runif(dim^2)*10-5, ncol=dim)
# self$sigma <- t(A) %*% A
}else self$sigma <- sigma
if (missing(sigma)) self$x0 <- rnorm(dim, sd = 1)
else self$x0 <- x0
if (!missing(niter)) self$niter <- niter
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)
self$burnin <- burnin
if (!missing(epsilon)) self$eps <- epsilon
if (!missing(nleaps)) self$nleaps <- nleaps
},
proposal = function(x){
p <- t(rmvnorm(1, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim))
self$m0 <- p
for (i in 1:self$nleaps){
x_p0 <- x
p <- p - 0.5 * self$eps * self$target.prob.log.grad(x)
x <- x + self$eps * solve(self$sigma) %*% p
p <- p - 0.5 * self$eps * self$target.prob.log.grad(x)
if (any(is.nan(x)) & is.null(first_nan)) {
print("HELLO, QORS")
print(x_p0)
}
}
self$mL <- p
return(x)
},
hamiltonian = function(x, p){
plog_tmp <<- self$target.prob.log(x)
p_tmp <<- p
x_tmp <<- x
return(self$target.prob.log(x) + 0.5 * t(p) %*% solve(self$sigma) %*% p)
},
sample_loop = function(){
p0 <- t(t(self$x0))
p <- p0
start.time <- Sys.time()
for (i in 1:self$niter){
p <- self$proposal(p)
logr <- self$hamiltonian(p0, self$m0) - self$hamiltonian(p, self$mL)
if (is.nan(logr)){
if (is.null(first_nan)){
first_nan <<- i
h0 <<- self$hamiltonian(p0, self$m0)
h1 <<- self$hamiltonian(p, self$mL)
plog <<- plog_tmp
prop <<- p_tmp
hpx <<- x_tmp
}
next
}
if (log(runif(1)) < logr) p0 <- p
curr.time <- Sys.time()
self$samples[i,] <- c(curr.time - start.time, p0)
}
return(self$samples)
},
sample = function(){
if (self$burnin){
for (i in 1:self$nburn){
S_b <- self$sample_loop()
self$sigma <- cov(S_b[,2:ncol(S_b)], use="complete.obs")
if (all(self$sigma < 1)){
if (all(self$sigma < 1) == 1) self$sigma <- diag(self$dim)
self$sigma <- self$sigma / max(abs(self$sigma))
}
}
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)  # clear burn-in samples
}
return(self$sample_loop())
}
))
RS <- R6Class("RS",
public = list(
samples = NULL, niter = 1000, nburn = 3, burnin = FALSE, dim = NULL,
sigma = NULL, x0 = NULL, name="RS",
target.prob = NULL, target.prob.log = NULL, M = NULL,
initialize = function(f, f.log, f.log.grad, dim, niter, burnin=TRUE, x0, sigma, const, epsilon, nleaps) {
if (missing(f)) stop("Target undefined")
self$target.prob <- f
if (missing(f.log)) stop("Target log undefined")
self$target.prob.log <- f.log
if (missing(dim)) stop("Dimensions undefined")
self$dim <- dim
if (missing(sigma)){
self$sigma <- diag(dim)
}else self$sigma <- sigma
if (missing(const)) self$M <- 0
else self$M <- log(const)
if (missing(sigma)) self$x0 <- rnorm(dim, sd = 5)
else self$x0 <- x0
if (!missing(niter)) self$niter <- niter
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)
self$burnin <- burnin
},
proposal = function(x){
return(rmvnorm(1, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim))
},
proposal.prob = function(x){
return(dmvnorm(x=x, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim))
},
proposal.prob.log = function(x){
return(log(dmvnorm(x=x, mean=rep(0, self$dim), sigma=2.4^2*self$sigma/self$dim)))
# return(-0.5 * (self$dim * log(2*pi) + log(self$sigma) + t(x) %*% solve(self$sigma) %*% x))
},
sample_loop = function(){
p <- self$x0
start.time <- Sys.time()
for (i in 1:self$niter){
p <- self$proposal(p)
p_prob.log <- self$proposal.prob.log(p)
t_prob.log <- self$target.prob.log(p)
logr <- (t_prob.log - p_prob.log - self$M)
if (is.nan(logr)) next
if (log(runif(1)) > logr) next
curr.time <- Sys.time()
self$samples[i,] <- c(curr.time - start.time, p)
}
return(self$samples)
},
sample = function(){
if (self$burnin){
for (i in 1:self$nburn){
S_b <- self$sample_loop()
self$sigma <- cov(S_b[,2:ncol(S_b)], use="complete.obs")
}
self$samples <- matrix(NA, nrow=self$niter, ncol=self$dim+1)  # clear burn-in samples
}
return(self$sample_loop())
}
))
# SHOULD I USE MEAN: DECREASES VARIANCE
traceplot <- function(df){
tf <- tibble(df)
xlen <- dim(df)[2]-5
xcols <- paste0(rep("x"), seq(xlen))
# print(xlen)
tf <- gather(df, key = "param", value = "d", xcols)
tf["tune"][tf$tune, ] <- "tuned"
tf["tune"][tf$tune != "tuned", ] <- "~tuned"
rf <- tf %>% group_by(across(all_of(c("alg", "run", "iter", "tune", "param")))) %>%
summarise_at(vars("d"), list(d = mean))
# print(head(rf))
# show only largest and smallest xvalues and middle
# TODO: if neccesarry
g <- ggplot(rf, aes(x=iter, y=d, group=param)) + geom_line(aes(color=param), alpha=.4)
return(g + facet_wrap(~tune + alg, nrow=2))
}
# autocorrelation
autocorr <- function(df){
dlen <- dim(df)[2]-5
xcols <- paste0(rep("x"), seq(dlen))
lcols <- paste0(rep("lag_x"), seq(dlen))
rf <- data.frame(matrix(ncol=2 * dlen + 2, nrow=0))
colnames(rf) <- c("alg", "tune", "var", "lag", "val")
for (a in unique(df$alg)){
for (t in unique(df$tune)){
for (xcol in xcols){
for (i in 1:5){
plt <- acf(df[(df$run == i) & (df$alg == a) & (df$tune == t), xcol], lag.max = 100, na.action=na.pass, plot = FALSE)
for (j in c(1)){
for (k in c(1)){
cbplt <- cbind(plt$lag[,k,j], plt$acf[,k,j])
rf <- rbind(rf, cbind(matrix(rep(a, dim(cbplt)[1]), ncol = 1), matrix(rep(t, dim(cbplt)[1]), ncol = 1), matrix(rep(xcol, dim(cbplt)[1]), ncol = 1), cbplt))
}
}
}
}
}
}
colnames(rf) <- c("alg", "tune", "var", "lag", "val")
rf <- transform(rf, tune = as.logical(tune), lag = as.numeric(lag), val = as.numeric(val))
gf <- aggregate(. ~ alg+tune+var+lag, data=rf, FUN=mean)
gf <- rf[rf$lag > 0,]
gf[,"lag"] <- ceiling(gf$lag / 10) * 10
gf_sd <- aggregate(. ~ alg+tune+var+lag, data=gf, FUN=function(x) return(sqrt(var(x))))
gf <- aggregate(. ~ alg+tune+var+lag, data=gf, FUN=mean)
gf[, "sd"] <- gf_sd$val
g <- ggplot(data=gf, aes(x=lag, y=val, fill=alg)) + geom_bar(stat="identity", position=position_dodge(5), width=3) +
geom_errorbar(aes(ymin=val-sd, ymax=val+sd), width=.1, position=position_dodge(5)) + facet_wrap(~tune+var)
return(g)
}
# ESS
wess <- function(df){
df <- na.omit(df)
dlen <- dim(df)[2]-5
xcols <- paste0(rep("x"), seq(dlen))
rf <- data.frame(matrix(ncol=dlen + 2, nrow=0))
colnames(rf) <- c("alg", "tune", xcols)
dlen <- dim(df)[2]-5
xcols <- paste0(rep("x"), seq(dlen))
rf <- data.frame(matrix(ncol=dlen, nrow=0))
colnames(rf) <- xcols
for (a in unique(df$alg)){
for (t in unique(df$tune)){
for (i in 1:5){
ess_i <- ess(df[(df$run == i) & (df$alg == a) & (df$tune == t), xcols])
ess_i <- c(a, t, ess_i)
rf <- rbind(rf, ess_i)
}
}
}
colnames(rf) <- c("alg", "tune", xcols)
mu_rf <- aggregate(. ~ alg + tune, data=rf, FUN=function(x) mean(as.numeric(x)))
std_rf <- aggregate(. ~ alg + tune, data=rf, FUN=function(x) sqrt(var(as.numeric(x))))
rf <- cbind(mu_rf, std_rf[, xcols])
return(rf[order(apply(rf[,xcols], 1, FUN=sum)),])
}
# ESS per second
wesssec <- function(df){
df <- na.omit(df)
dlen <- dim(df)[2]-5
xcols <- paste0(rep("x"), seq(dlen))
rf <- data.frame(matrix(ncol=dlen + 2, nrow=0))
colnames(rf) <- c("alg", "tune", xcols)
dlen <- dim(df)[2]-5
xcols <- paste0(rep("x"), seq(dlen))
rf <- data.frame(matrix(ncol=dlen, nrow=0))
colnames(rf) <- xcols
for (a in unique(df$alg)){
for (t in unique(df$tune)){
for (i in 1:5){
idf <- df[df$run == i, c("time", xcols)]
ess_i <- ess(df[(df$run == i) & (df$alg == a) & (df$tune == t), xcols])
ess_i <- c(a, t, ess_i / max(idf$time))
rf <- rbind(rf, ess_i)
}
}
}
colnames(rf) <- c("alg", "tune", xcols)
mu_rf <- aggregate(. ~ alg + tune, data=rf, FUN=function(x) mean(as.numeric(x)))
std_rf <- aggregate(. ~ alg + tune, data=rf, FUN=function(x) sqrt(var(as.numeric(x))))
rf <- cbind(mu_rf, std_rf[, xcols])
return(rf[order(apply(rf[,xcols], 1, FUN=sum)),])
}
# convergence plot
converge_plot <- function(df){
dlen <- dim(df)[2]-5
xcols <- paste0(rep("x"), seq(dlen))
idf <- data.frame(matrix(ncol = 4 + dlen, nrow = 0))
tdf<- data.frame(matrix(ncol = 4 + dlen, nrow = 0))
for (a in unique(df$alg)){
for (r in unique(df$run)){
for (tn in c(TRUE, FALSE)){
for(t in sort(unique(df$time))){
cm <- colMeans(df[(df$alg == a) & (df$run == r) & (df$time <= t) & (df$tune == tn), xcols])
tdf <- rbind(tdf, cbind(c(a, r, tn, t), cm))
}
for(i in sort(unique(df$iter))){
cm <- colMeans(df[(df$alg == a) & (df$run == r) & (df$iter <= i) & (df$tune == tn), xcols])
idf <- rbind(idf, cbind(c(a, r, tn, i), cm))
}
}
}
}
return(idf)
}
generate_results <- function(f, f.log, f.log.grad, dim = 2, const = 1, epsilon = 1, nleaps = 10, tunelist = list(FALSE, TRUE), samplers = list(RS, MHS, HMC)){
xlen <- dim
xcols <- paste0(rep("x"), seq(xlen))
df <- data.frame(matrix(ncol = 5 + dim, nrow = 0))
colnames(df) <- c("alg", "tune", "run", "iter", "time", xcols)
niter <- 1000
# for method in methodology
for (obj in samplers){
# apply twice
for (burnin in tunelist){
# repeat n-times for uncertainty estimation
for (i in 1:5) {
sampler <- obj$new(f = f, f.log = f.log, f.log.grad = f.log.grad, dim = dim, niter = niter, burnin = burnin, epsilon = epsilon, nleaps = nleaps, const = const)
tp <- sampler$sample()
df_nsamp <- data.frame(tp)
colnames(df_nsamp) <- c("time", xcols)
df_nsamp$iter <- seq(niter)
df_nsamp$alg <- sampler$name
df_nsamp$tune <- burnin
df_nsamp$run <- i
df <- rbind(df, df_nsamp)
}
}
}
return(df)
}
present_results <- function(df, name, keypoints = NULL){
# check whether shape is correct
g <- ggplot(df, aes(x=x1, y=x2, color = tune)) + geom_point()
if (!is.null(keypoints))
g <- g + geom_point(aes(x=keypoints[1], y=keypoints[2]), colour="blue")
plt <- g + facet_wrap(~tune+alg)
print(plt)
# plot traceplot
options(repr.plot.width=15, repr.plot.height=8)
plt <- traceplot(df)
ggsave(paste("./img/", name, "_traceplot.png"), plot = plt, dpi=100)
print(plt)
# plot autocorrelation
plt <- autocorr(df)
ggsave(paste("./img/", name, "_acf.png"), plot = plt, dpi=100)
print(plt)
# calculate ESS
ress <- wess(df)
print(ress)
write.csv(ress, paste("./table/ess-", name, ".csv"), row.names=TRUE)
# calculate ESS/second (maybe ESS per second)
resssec <- wesssec(df)
print(resssec)
write.csv(ress, paste("./table/esssec-", name, ".csv"), row.names=TRUE)
}
covmat <- diag(2)
# covmat <- matrix(c(2, -1, -1, 2), nrow=2)
bivar.prob = function(x){
return(dmvnorm(x=c(x), mean=rep(0, 2), sigma=covmat))
}
bivar.prob.log = function(x){
return(log(dmvnorm(x=c(x), mean=rep(0, 2), sigma=covmat)))
}
bivar.log.grad = function(x){
return(-solve(covmat) %*% x)
}
df.bivar <- generate_results(f = bivar.prob, f.log = bivar.prob.log, f.log.grad = bivar.log.grad, tunelist = list(FALSE, TRUE), samplers = list(RS, MHS, HMC))
present_results(df.bivar, "bivar")
cdir()
getwd()
